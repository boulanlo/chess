#+Title: Available captures for the rook; a performance analysis on a parallelized version of the problem
#+Author: Louis Boulanger

* Foreword
This document has been generated from an =org-mode= file. The source can
be found here ([[./report.org][Source]]), and a PDF version here ([[./report.pdf][PDF]]). I aimed to have
both the GitHub-ready org-mode file and the PDF to be readable, but
unfortunately, GitHub doesn't support mathematical expressions to be
rendered natively on the preview; so, in order to view correctly the
mathematical formulas throughout the analysis, I recommend reading the
PDF version.

* Introduction
#+Begin_src python :session :results none :exports none
import chess
import chess.svg
import sys
from cairosvg import svg2png

def draw_board(name, fen, attacks="a1"):
    board = chess.Board(fen)
    squares = board.attacks(chess.parse_square(attacks))
    svg = chess.svg.board(board=board, squares=squares)
    svg2png(bytestring=svg, output_width="300px", write_to="img/{}.png".format(name))
#+End_src


This project aims to implement a solution for the problem of the
number of available captures for the rook on a chessboard: on a
chessboard, where pieces are either *a black rook*, *black bishops* or
*white pawns*, how many pawns can the rook capture? 

#+Begin_src python :session :results output graphics file :file example1.png :output-dir img/ :exports results
draw_board("example1", "4P3/5P2/2P1r3/6P1/4b3/4P3/8/8 w - - 0 1", attacks="e6")
#+End_src

#+RESULTS:
[[file:img/example1.png]]

In this example, the rook can only capture 2 pawns: e8 and c6. The
pawn on e3 is blocked by the bishop on e4.

* Base algorithm
The base algorithm is quite simple: given a board and the position of
the rook, we need to iterate on the squares in the 4 directions: if
the first piece encountered is a bishop, there is no capture on this
position; and if it's a pawn, there is a capture. The result is the
sum of the number of captures.

#+Include: "src/board.rs" src rust :lines "172-204"

* First attempt at parallelization using Rayon
We can attempt to parallelize the algorithm in a straightforward
manner, by looking at the 4 different directions in parallel. This
version of the algorithm is quite similar to the sequential one: using
Rayon's powerful parallel iterators, we can simply iterate in parallel
on the directions.

#+Include: "src/board.rs" src rust :lines "205-230"

** Theoretical performance analysis of the parallel version
Let's analyze the parallel algorithm. We first formally define a board
as a 2-dimensional space of size $N^2$. There are 4 parallel branches,
each iterating on successive squares of the board. Deciding on the
capture is $\mathcal{O}(1)$, so the exploration of a line takes
$\mathcal{O}(N)$ at most.

We then have a work of $W = \mathcal{O}(4N)$, and a depth of
$D = \mathcal{O}(N)$. It is obvious here that having more than 4
processors for the task is going to be detrimental for the
performances.
